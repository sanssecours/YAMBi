%skeleton "lalr1.cc"
%defines
%define api.token.constructor
%define api.value.type variant
%define parse.assert
%code requires
{
#include <string>
class Driver;
class Lexer;
}
// The parsing context.
%parse-param { Lexer& lexer }
%parse-param { Driver& driver }
%locations
%initial-action
{
  // Initialize the initial location.
  @$.begin.filename = @$.end.filename = &driver.filename;
};
%define parse.trace
%define parse.error verbose
%code
{
# include "driver.hpp"

#undef yylex
#define yylex lexer.nextToken
}
%define api.token.prefix {TOKEN_}
%token
  END  0  "end of file"
;
%token <std::string> STREAM_START
%token <std::string> STREAM_END
%token <std::string> PLAIN_SCALAR
%token <std::string> BLOCK_END
%token <std::string> SINGLE_QUOTED_SCALAR
%token <std::string> DOUBLE_QUOTED_SCALAR
%token <std::string> COMMENT
%token <std::string> MAPPING_START
%token <std::string> KEY
%token <std::string> VALUE
%token <std::string> SEQUENCE_START
%token <std::string> ELEMENT

%%

yaml: STREAM_START node STREAM_END
    ;

node : value
     | %empty
     ;

value : PLAIN_SCALAR { driver.exitValue($1); }
      ;

%%

void
yy::parser::error (const location_type& location,
                   const std::string& message)
{
  driver.error (location, message);
}
